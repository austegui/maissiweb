---
phase: 11-notifications-real-time
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - src/hooks/use-realtime-sync.ts
  - src/app/page.tsx
  - src/components/conversation-list.tsx
autonomous: true

must_haves:
  truths:
    - "When one agent changes a conversation's status or assignment, all other connected agents see the update without refreshing"
    - "When one agent adds a note or edits a contact, the changes appear for other agents without refreshing"
    - "When label assignments change, the conversation list updates for all connected agents"
    - "If the Realtime connection drops, it automatically reconnects with exponential backoff"
    - "A subtle visual indicator shows when the Realtime connection is lost"
    - "Polling interval decreases to 5s as fallback when Realtime is disconnected, returns to 10s when reconnected"
  artifacts:
    - path: "src/hooks/use-realtime-sync.ts"
      provides: "Supabase Realtime multi-table subscription with reconnect logic, visibility change handling, and connection state"
      exports: ["useRealtimeSync"]
    - path: "src/components/conversation-list.tsx"
      provides: "Adjusted polling interval based on Realtime connection state"
    - path: "src/app/page.tsx"
      provides: "Realtime hook integration and connection state passed to ConversationList"
  key_links:
    - from: "src/app/page.tsx"
      to: "src/hooks/use-realtime-sync.ts"
      via: "useRealtimeSync hook call"
      pattern: "useRealtimeSync"
    - from: "src/hooks/use-realtime-sync.ts"
      to: "@supabase/supabase-js Realtime"
      via: "supabase.channel().on('postgres_changes').subscribe()"
      pattern: "postgres_changes"
    - from: "src/app/page.tsx"
      to: "src/components/conversation-list.tsx"
      via: "realtimeConnected prop driving polling interval"
      pattern: "realtimeConnected"
---

<objective>
Build the Supabase Realtime sync hook that subscribes to metadata table changes (conversation_metadata, conversation_notes, conversation_contact_labels, contacts) and integrate it into the inbox so all connected agents see instant updates. Add connection resilience with automatic reconnection, visibility change handling, a disconnected indicator, and polling fallback.

Purpose: Multi-agent coordination — when one agent changes status, assignment, labels, notes, or contacts, all others see it instantly without refreshing. Connection drops are handled gracefully.
Output: Real-time metadata sync across all connected agents with resilient connection management.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-notifications-real-time/11-RESEARCH.md
@.planning/phases/11-notifications-real-time/11-02-SUMMARY.md
@src/hooks/use-auto-polling.ts
@src/components/conversation-list.tsx
@src/app/page.tsx
@src/lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Realtime sync hook with multi-table subscriptions and reconnection</name>
  <files>
    src/hooks/use-realtime-sync.ts
  </files>
  <action>
    Create `src/hooks/use-realtime-sync.ts` that manages Supabase Realtime channel subscriptions for four tables with automatic reconnection and visibility change handling.

    **Interface:**
    ```typescript
    type UseRealtimeSyncOptions = {
      onDataChange: () => void;  // callback to trigger re-fetch (e.g., fetchConversations)
    };

    type UseRealtimeSyncReturn = {
      realtimeConnected: boolean;
    };
    ```

    **Implementation details:**

    1. **Supabase client**: Create browser client via `createClient()` from `@/lib/supabase/client`. Use `useMemo` so it's stable across renders.

    2. **Channel subscriptions**: Subscribe to ONE channel with MULTIPLE `.on('postgres_changes', ...)` handlers chained. This is more efficient than creating 4 separate channels. Use a single channel named `'realtime:metadata-sync'`.

    Tables to subscribe:
    - `conversation_metadata` — event: `'*'`, schema: `'public'`, no filter (table-wide)
    - `conversation_contact_labels` — event: `'*'`, schema: `'public'`, no filter (table-wide)
    - `contacts` — event: `'*'`, schema: `'public'`, no filter (table-wide)
    - `conversation_notes` — event: `'INSERT'`, schema: `'public'`, no filter (new notes only; we don't need update/delete for notes)

    3. **On any event**: Call `onDataChange()` which triggers the parent to re-fetch conversations. Use a debounce: batch rapid events (within 500ms) into a single re-fetch. Implement with a `setTimeout` ref that gets cleared and reset on each event.

    4. **Connection state**: Track `realtimeConnected` via `useState(false)`. Set to `true` on `'SUBSCRIBED'` status, `false` on `'CHANNEL_ERROR'`, `'TIMED_OUT'`, or `'CLOSED'`.

    5. **Reconnection with exponential backoff**: On error status, call `supabase.removeChannel(channel)`, then `setTimeout(subscribe, retryDelay)`. Start at 3000ms, double on each retry, cap at 30000ms. Reset to 3000ms on successful `SUBSCRIBED`.

    6. **isMounted flag**: Prevent reconnect attempts after component unmount (React Strict Mode safety).

    7. **Visibility change handler**: On `document.visibilitychange`:
       - When tab becomes visible (`!document.hidden`): Remove existing channel, clear reconnect timer, reset backoff, call `subscribe()` again (fresh token on reconnect). Also call `onDataChange()` immediately to refresh stale data.
       - When tab becomes hidden: Do nothing (keep channel alive; it will error naturally if JWT expires, and reconnect handles it).

    8. **Cleanup**: On unmount, set `isMounted = false`, remove `visibilitychange` listener, clear reconnect timer, `channel.unsubscribe()` + `supabase.removeChannel(channel)`.

    **Anti-patterns to avoid:**
    - Do NOT create multiple channels (one per table). Use a single channel with multiple `.on()` handlers.
    - Do NOT call `subscribe()` without first calling `removeChannel()` on the previous channel.
    - Do NOT use the server-side Supabase client. Realtime only works with the browser client.
    - Do NOT subscribe without the `isMounted` guard.
  </action>
  <verify>
    - `src/hooks/use-realtime-sync.ts` exports `useRealtimeSync`
    - The hook creates a single Supabase Realtime channel
    - Reconnection logic handles CHANNEL_ERROR, TIMED_OUT, CLOSED
    - Visibility change handler re-subscribes when tab becomes visible
    - No TypeScript errors in the file
  </verify>
  <done>The Realtime sync hook subscribes to all four metadata tables on a single channel with automatic reconnection, exponential backoff, visibility change handling, and a debounced re-fetch callback.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Realtime sync into page.tsx and add polling fallback to conversation-list</name>
  <files>
    src/app/page.tsx
    src/components/conversation-list.tsx
  </files>
  <action>
    **1. Update `src/app/page.tsx`:**

    - Import `useRealtimeSync` from `@/hooks/use-realtime-sync`
    - Create a stable callback for `onDataChange` that calls `conversationListRef.current?.refresh()`. Wrap in `useCallback` with empty deps (ref is stable).
    - Initialize: `const { realtimeConnected } = useRealtimeSync({ onDataChange: handleRealtimeChange });`
    - Pass `realtimeConnected` as a new prop to `ConversationList`.
    - Add a connection indicator in the header, next to the existing "Chats" title area or near the polling dot. When `realtimeConnected` is false, show a small amber/gray dot with a tooltip. Implementation:
      - In the header `<div>`, after the `NotificationToggle`, add:
        ```tsx
        {!realtimeConnected && (
          <span
            className="h-2 w-2 rounded-full bg-amber-400 animate-pulse"
            title="Reconectando tiempo real..."
          />
        )}
        ```
      This is subtle and matches the existing green polling dot style.

    **2. Update `src/components/conversation-list.tsx`:**

    - Add `realtimeConnected?: boolean` to the Props type.
    - Change the `useAutoPolling` interval from hardcoded `10000` to a dynamic value:
      ```typescript
      const pollingInterval = realtimeConnected === false ? 5000 : 10000;
      ```
      Use `realtimeConnected === false` (strict check) so that the default `undefined` (before hook initializes) uses the normal 10s interval.
    - Pass `pollingInterval` to `useAutoPolling({ interval: pollingInterval, ... })`.
    - The `useAutoPolling` hook already supports dynamic intervals via `baseIntervalRef.current = interval` — but check if it re-creates the polling timer when interval changes. If not, update `useAutoPolling` to accept a changing interval by adding a `useEffect` that updates `baseIntervalRef.current` and `currentIntervalRef.current` when `interval` prop changes, and restarts the timer.

    **3. Update `src/hooks/use-auto-polling.ts` (if needed):**

    If the interval prop is not reactive (i.e., changing it doesn't restart the poll cycle), add:
    ```typescript
    useEffect(() => {
      baseIntervalRef.current = interval;
      currentIntervalRef.current = interval;
    }, [interval]);
    ```
    This ensures that when `realtimeConnected` toggles, the polling interval updates on the next cycle.
  </action>
  <verify>
    - `npm run build` succeeds
    - `page.tsx` imports and calls `useRealtimeSync`
    - `page.tsx` passes `realtimeConnected` to `ConversationList`
    - `conversation-list.tsx` uses `realtimeConnected` to set polling interval (5s when disconnected, 10s when connected)
    - The header shows an amber dot when `realtimeConnected` is false
    - `useAutoPolling` responds to interval changes
  </verify>
  <done>Realtime sync is wired into the inbox. Metadata changes from other agents trigger automatic re-fetch. Connection state drives a visual indicator and polling fallback interval.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. `use-realtime-sync.ts` creates a single Supabase channel subscribed to 4 tables
3. `page.tsx` initializes `useRealtimeSync` and passes `realtimeConnected` to ConversationList
4. `conversation-list.tsx` polls at 5s when Realtime disconnected, 10s when connected
5. Header shows amber pulse dot when Realtime connection is lost
6. On tab visibility restore, the hook reconnects and triggers a data refresh
</verification>

<success_criteria>
- REALTIME-01: Status changes, assignment updates, label changes, notes, and contact edits appear instantly for all connected agents via Supabase Realtime triggering a re-fetch
- REALTIME-02: Polling continues for Kapso message data at 10s (unchanged behavior), with 5s fallback when Realtime is disconnected
- REALTIME-03: Automatic reconnection with exponential backoff (3s to 30s), visibility change re-subscribe, and visual indicator for disconnected state
</success_criteria>

<output>
After completion, create `.planning/phases/11-notifications-real-time/11-03-SUMMARY.md`
</output>
