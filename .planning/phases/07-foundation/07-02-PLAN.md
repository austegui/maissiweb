---
phase: 07-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: false
user_setup:
  - service: supabase
    why: "RBAC database foundation -- user_profiles table, trigger, RLS policies"
    dashboard_config:
      - task: "Run SQL statements in Supabase SQL Editor"
        location: "Supabase Dashboard -> SQL Editor -> New query"

must_haves:
  truths:
    - "A user_profiles table exists in Supabase with id, display_name, role, created_at, updated_at columns"
    - "When a new user signs up, a user_profiles row is automatically created with role='agent'"
    - "Existing team member accounts have user_profiles rows (backfilled)"
    - "The admin user's profile has role='admin'"
    - "A non-admin user cannot change their own role column via RLS"
    - "Only admin users can write to app_settings via RLS"
  artifacts:
    - path: "public.user_profiles (Supabase table)"
      provides: "Role-based user profiles"
      contains: "role CHECK (role IN ('admin', 'agent'))"
    - path: "public.handle_new_user() (Supabase function)"
      provides: "Auto-create profile on signup"
      contains: "SECURITY DEFINER SET search_path = ''"
    - path: "public.get_my_role() (Supabase function)"
      provides: "Cached role lookup for RLS policies"
      contains: "STABLE SECURITY DEFINER"
  key_links:
    - from: "auth.users INSERT"
      to: "public.user_profiles INSERT"
      via: "on_auth_user_created trigger"
      pattern: "handle_new_user"
    - from: "RLS policies"
      to: "public.get_my_role()"
      via: "SELECT subquery in USING/WITH CHECK"
      pattern: "get_my_role"
---

<objective>
Create the RBAC database foundation in Supabase: user_profiles table, auto-create trigger, RLS policies, and backfill existing users.

Purpose: This is the database layer that every subsequent v2.0 phase depends on. Without user_profiles, there is no role system. Without RLS, there is no security enforcement at the DB level.

Output: A fully configured Supabase database with user_profiles table, trigger, RLS policies, backfilled users, and an admin user promoted.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation/07-RESEARCH.md
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Create user_profiles table, trigger, and helper function in Supabase</name>
  <action>
  The user must run the following SQL statements in the Supabase Dashboard SQL Editor (Dashboard -> SQL Editor -> New query). Run them in order, one block at a time.

  **Block 1: Create user_profiles table**
  ```sql
  CREATE TABLE public.user_profiles (
    id          UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    display_name TEXT NOT NULL DEFAULT '',
    role        TEXT NOT NULL DEFAULT 'agent' CHECK (role IN ('admin', 'agent')),
    created_at  TIMESTAMPTZ DEFAULT now(),
    updated_at  TIMESTAMPTZ DEFAULT now()
  );

  ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
  ```

  **Block 2: Create trigger function for auto-creating profiles on signup**
  ```sql
  CREATE OR REPLACE FUNCTION public.handle_new_user()
  RETURNS trigger
  LANGUAGE plpgsql
  SECURITY DEFINER SET search_path = ''
  AS $$
  BEGIN
    INSERT INTO public.user_profiles (id, display_name, role)
    VALUES (
      NEW.id,
      COALESCE(NEW.raw_user_meta_data ->> 'full_name', NEW.email, ''),
      'agent'
    );
    RETURN NEW;
  END;
  $$;

  CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE PROCEDURE public.handle_new_user();
  ```

  **Block 3: Create role lookup helper function**
  ```sql
  CREATE OR REPLACE FUNCTION public.get_my_role()
  RETURNS text
  LANGUAGE sql
  STABLE
  SECURITY DEFINER SET search_path = ''
  AS $$
    SELECT role FROM public.user_profiles WHERE id = auth.uid();
  $$;
  ```

  **Block 4: Create RLS policies on user_profiles**
  ```sql
  CREATE POLICY "Users can read own profile"
    ON public.user_profiles
    FOR SELECT
    TO authenticated
    USING ( (SELECT auth.uid()) = id );

  CREATE POLICY "Admins can read all profiles"
    ON public.user_profiles
    FOR SELECT
    TO authenticated
    USING ( (SELECT public.get_my_role()) = 'admin' );

  CREATE POLICY "Users can update own display_name"
    ON public.user_profiles
    FOR UPDATE
    TO authenticated
    USING ( (SELECT auth.uid()) = id )
    WITH CHECK (
      (SELECT auth.uid()) = id
      AND role = (SELECT role FROM public.user_profiles WHERE id = auth.uid())
    );

  CREATE POLICY "Only admins can change roles"
    ON public.user_profiles
    FOR UPDATE
    TO authenticated
    USING ( (SELECT public.get_my_role()) = 'admin' );
  ```

  **Block 5: Add RLS policies on app_settings (admin-only writes)**
  ```sql
  ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

  CREATE POLICY "Authenticated users can read settings"
    ON public.app_settings
    FOR SELECT
    TO authenticated
    USING (true);

  CREATE POLICY "Only admins can insert settings"
    ON public.app_settings
    FOR INSERT
    TO authenticated
    WITH CHECK ( (SELECT public.get_my_role()) = 'admin' );

  CREATE POLICY "Only admins can update settings"
    ON public.app_settings
    FOR UPDATE
    TO authenticated
    USING ( (SELECT public.get_my_role()) = 'admin' );
  ```

  Each block should show "Success. No rows returned." or similar. If any block fails, do NOT proceed to the next one -- report the error.
  </action>
  <resume-signal>Type "done" after all 5 SQL blocks have executed successfully in the Supabase SQL Editor.</resume-signal>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Backfill existing users and promote admin</name>
  <action>
  Run the following SQL in the Supabase SQL Editor. This must happen AFTER Task 1.

  **Step 1: Backfill all existing auth.users into user_profiles**
  ```sql
  INSERT INTO public.user_profiles (id, display_name, role)
  SELECT
    id,
    COALESCE(raw_user_meta_data ->> 'full_name', email, ''),
    'agent'
  FROM auth.users
  ON CONFLICT (id) DO NOTHING;
  ```

  **Step 2: Find your admin user UUID**
  ```sql
  SELECT id, email FROM auth.users;
  ```
  Copy the UUID for the email address that should be the admin (Gustavo's email).

  **Step 3: Promote admin user** (replace UUID below with the actual value from Step 2)
  ```sql
  UPDATE public.user_profiles
  SET role = 'admin'
  WHERE id = '<paste-admin-uuid-here>';
  ```

  **Step 4: Verify everything is correct**
  ```sql
  SELECT u.email, p.role, p.display_name
  FROM auth.users u
  JOIN public.user_profiles p ON u.id = p.id;
  ```
  This should show all team members with their roles. The admin's email should show `role = 'admin'`, all others should show `role = 'agent'`.
  </action>
  <resume-signal>Type "done" and paste the output of Step 4 (the verification query) so we can confirm the roles are correct.</resume-signal>
</task>

</tasks>

<verification>
1. `user_profiles` table exists in Supabase Table Editor with correct columns
2. `handle_new_user` trigger exists (check Functions tab in Supabase Dashboard)
3. RLS is enabled on both `user_profiles` and `app_settings` (green shield icon in Table Editor)
4. Admin user has `role = 'admin'` in user_profiles
5. All existing team members have user_profiles rows
</verification>

<success_criteria>
- user_profiles table created with id, display_name, role, created_at, updated_at
- Trigger auto-creates profile rows for new signups with role='agent'
- Existing users backfilled into user_profiles
- Admin user promoted to role='admin'
- RLS policies prevent self-role-change
- app_settings has RLS with admin-only writes
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation/07-02-SUMMARY.md`
</output>
