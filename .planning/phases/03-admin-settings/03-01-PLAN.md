---
phase: 03-admin-settings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/get-config.ts
  - src/app/api/settings/route.ts
autonomous: true

must_haves:
  truths:
    - "getConfig() returns a DB value when one exists for the requested key"
    - "getConfig() falls back to process.env when no DB row exists"
    - "GET /api/settings returns current credential rows for authenticated users"
    - "POST /api/settings upserts credential rows for authenticated users"
    - "Unauthenticated requests to /api/settings return 401 JSON"
  artifacts:
    - path: "src/lib/get-config.ts"
      provides: "Async credential resolver with DB-first, env fallback"
      exports: ["getConfig"]
    - path: "src/app/api/settings/route.ts"
      provides: "HTTP read/write interface for app_settings table"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/lib/get-config.ts"
      to: "app_settings table"
      via: "createClient() from @/lib/supabase/server"
      pattern: "supabase\\.from\\('app_settings'\\)"
    - from: "src/app/api/settings/route.ts"
      to: "app_settings table"
      via: "createClient() from @/lib/supabase/server"
      pattern: "supabase\\.from\\('app_settings'\\)"
---

<objective>
Create the getConfig() credential resolver utility and the /api/settings REST route handler.

Purpose: These two server-side modules form the backend foundation for Phase 3. getConfig() is the async function that all Kapso routes will eventually call (Phase 4) to resolve credentials from the database instead of process.env. The /api/settings route provides an authenticated HTTP interface for reading and writing the app_settings table.

Output: Two new files — src/lib/get-config.ts and src/app/api/settings/route.ts
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-admin-settings/03-RESEARCH.md
@src/lib/supabase/server.ts
@src/lib/whatsapp-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create getConfig() utility</name>
  <files>src/lib/get-config.ts</files>
  <action>
Create src/lib/get-config.ts with:

1. Define a ConfigKey type union: 'KAPSO_API_KEY' | 'WHATSAPP_API_URL' | 'PHONE_NUMBER_ID' | 'WABA_ID'

2. Define ENV_FALLBACKS record mapping each ConfigKey to its process.env value:
   - KAPSO_API_KEY: process.env.KAPSO_API_KEY
   - WHATSAPP_API_URL: process.env.WHATSAPP_API_URL || 'https://api.kapso.ai/meta/whatsapp'
   - PHONE_NUMBER_ID: process.env.PHONE_NUMBER_ID || ''
   - WABA_ID: process.env.WABA_ID

3. Export async function getConfig(key: ConfigKey): Promise<string>
   - Call createClient() from @/lib/supabase/server (await it — Next.js 15 async cookies)
   - Query: supabase.from('app_settings').select('value').eq('key', key).maybeSingle()
   - Use .maybeSingle() NOT .single() — .single() throws when no row exists
   - If data?.value is truthy, return data.value
   - Otherwise fall back to ENV_FALLBACKS[key]
   - If fallback is undefined (not just empty string), throw Error with descriptive message
   - If fallback is empty string (like PHONE_NUMBER_ID default), return it — don't throw

4. Also export the ConfigKey type for use by other modules.

IMPORTANT: getConfig() is async. It returns Promise<string>. Phase 4 will need to make callers async — that is NOT this plan's scope. This plan only creates the utility.
  </action>
  <verify>
File exists at src/lib/get-config.ts. Contains: export async function getConfig, import from @/lib/supabase/server, .maybeSingle(), ENV_FALLBACKS record, ConfigKey type export.
  </verify>
  <done>getConfig() utility created with DB-first query via Supabase, env fallback for all 4 config keys, and proper error for missing required keys.</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/settings route handler</name>
  <files>src/app/api/settings/route.ts</files>
  <action>
Create src/app/api/settings/route.ts with GET and POST handlers:

**GET handler:**
1. Call createClient() from @/lib/supabase/server
2. Auth check: const { data: { user } } = await supabase.auth.getUser()
   - If !user, return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
   - Use getUser() NOT getSession() — project decision from Phase 2
3. Query: supabase.from('app_settings').select('key, value')
4. If error, return NextResponse.json({ error: error.message }, { status: 500 })
5. Return NextResponse.json({ data })

**POST handler:**
1. Call createClient() from @/lib/supabase/server
2. Auth check (same as GET — getUser(), 401 if not authenticated)
3. Parse body: const body = await request.json()
4. Extract: const updates = body.settings as Array<{ key: string; value: string }>
5. Upsert: supabase.from('app_settings').upsert(updates, { onConflict: 'key' })
   - onConflict: 'key' is required because the unique constraint is on the `key` column, not the primary key `id`
6. If error, return NextResponse.json({ error: error.message }, { status: 500 })
7. Return NextResponse.json({ success: true })

Import NextResponse from 'next/server' and createClient from '@/lib/supabase/server'.

IMPORTANT: The middleware returns 302 redirects for unauthenticated requests, which is wrong for API consumers. The route-level auth check returns proper 401 JSON. This is intentional and must NOT be removed even though middleware also protects the route.
  </action>
  <verify>
File exists at src/app/api/settings/route.ts. Contains: export async function GET, export async function POST, getUser() auth check in both handlers, upsert with onConflict: 'key', 401 response for unauthenticated requests.
  </verify>
  <done>GET /api/settings returns all credential rows for authenticated users. POST /api/settings upserts credential rows. Both return 401 JSON for unauthenticated requests.</done>
</task>

</tasks>

<verification>
1. src/lib/get-config.ts exists and exports getConfig (async) and ConfigKey type
2. src/app/api/settings/route.ts exists and exports GET and POST
3. Both files import createClient from @/lib/supabase/server
4. getConfig uses .maybeSingle() (not .single())
5. API route uses getUser() (not getSession())
6. API route uses upsert with { onConflict: 'key' }
7. No TypeScript compilation errors (npx tsc --noEmit or build check)
</verification>

<success_criteria>
- getConfig() is a working async function that queries app_settings and falls back to process.env
- /api/settings provides authenticated GET (read all) and POST (upsert) for the app_settings table
- Both files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-admin-settings/03-01-SUMMARY.md`
</output>
